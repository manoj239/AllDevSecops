name: Java CI-CD Pipeline

on:
  push:
    branches: ["master"]

jobs:
  ci-cd:
    runs-on: ubuntu-latest

    steps:
      # 1. Checkout
      - name: Checkout code
        uses: actions/checkout@v4

      # 2. Setup Java
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      # 3. Build & Test
      - name: Build & Test
        run: mvn -B clean verify

      # 4. Package
      - name: Package JAR
        run: mvn -B package

      # 5. SonarQube
      - name: SonarQube Analysis
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        run: |
          mvn sonar:sonar \
            -Dsonar.projectKey=my-java-app \
            -Dsonar.host.url=${SONAR_HOST_URL} \
            -Dsonar.login=${SONAR_TOKEN} \
            -Dsonar.qualitygate.wait=true

      # 6. Upload artifact to JFrog (CD STARTS HERE)
      - name: Upload artifact to JFrog Artifactory
        run: |
          curl -u ${{ secrets.JFROG_USER }}:${{ secrets.JFROG_API_KEY }} \
          -T target/*.jar \
          "${{ secrets.JFROG_URL }}/artifactory/libs-release-local/my-java-app/myapp.jar"
-----------------

name: Simple Java CD Pipeline

on:
  workflow_run:
    workflows: [ "Java CI Pipeline" ]   # If UI shows "ci.yml", change this to [ "ci.yml" ]
    types: [ completed ]

jobs:
  cd:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest

    permissions:
      actions: read
      contents: read

    steps:
      # 1) Diagnostic: list artifacts in the upstream CI run
      - name: Debug – list artifacts in CI run
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          RUN_ID: ${{ github.event.workflow_run.id }}
          REPO: ${{ github.repository }}
        run: |
          echo "Upstream CI run ID: $RUN_ID"
          curl -s \
            -H "Authorization: Bearer $GH_TOKEN" \
            -H "Accept: application/vnd.github+json" \
            "https://api.github.com/repos/$REPO/actions/runs/$RUN_ID/artifacts" | jq .

      # 2) Download the artifact produced by CI
      - name: Download artifact
        uses: actions/download-artifact@v4
        with:
          name: java-artifact               # must match CI upload name
          run-id: ${{ github.event.workflow_run.id }}
          path: artifact
          github-token: ${{ secrets.GITHUB_TOKEN }}

      # 3) Show what we downloaded
      - name: List files
        run: ls -la artifact

      # 4) Upload to JFrog Artifactory using Identity/Access Token
      - name: Upload to JFrog (Identity/Access Token)
        env:
          JFROG_URL: ${{ secrets.JFROG_URL }}
          JFROG_ACCESS_TOKEN: ${{ secrets.JFROG_ACCESS_TOKEN }}
          JFROG_REPO: libs-release-local          # change if you use a different repo
          GROUP_PATH: com/manoj                   # adjust to your groupId
          ARTIFACT_NAME: my-java-app              # adjust to your artifactId
          ARTIFACT_VERSION: 1.0-SNAPSHOT          # adjust; you can parse from pom.xml later
        run: |
          set -e

          # Validate secrets and inputs
          if [ -z "$JFROG_URL" ]; then
            echo "ERROR: JFROG_URL is empty. Set it in repo Secrets."; exit 1;
          fi
          if [ -z "$JFROG_ACCESS_TOKEN" ]; then
            echo "ERROR: JFROG_ACCESS_TOKEN is empty. Set it in repo Secrets."; exit 1;
          fi

          echo "JFrog URL: $JFROG_URL"
          echo "Repo: $JFROG_REPO"
          echo "Group path: $GROUP_PATH"
          echo "Artifact: $ARTIFACT_NAME"
          echo "Version: $ARTIFACT_VERSION"

          # Resolve downloaded JAR path
          JAR_PATH=$(ls artifact/*.jar | head -n 1)
          if [ ! -f "$JAR_PATH" ]; then
            echo "ERROR: No JAR found under artifact/"; ls -la artifact; exit 1;
          fi
          echo "Uploading $JAR_PATH"

          # Build Maven-like target path in Artifactory
          TARGET_URL="$JFROG_URL/artifactory/$JFROG_REPO/$GROUP_PATH/$ARTIFACT_NAME/$ARTIFACT_VERSION/${ARTIFACT_NAME}-${ARTIFACT_VERSION}.jar"
          echo "Target URL: $TARGET_URL"

          # Upload with Bearer token
          curl -fSL \
            -H "Authorization: Bearer $JFROG_ACCESS_TOKEN" \
                       -T "$JAR_PATH" \
            "$TARGET_URL"

deployment role is assumed by the Github actions, automation role is  assumed by the SSM docuemtns

1)First created the Github runner role in monitoring deploy account

2)Create the runner as well

Yet to do

3)Create workflows - (validate CF, deploy CF)

4)Create automation role in monitoring-dev

5)Create deployment role in monitoring-dev
GitHub Actions → Build Java app → Build Docker image → Push to ECR → Deploy to ECS (Fargate)
"I have implemented CI using GitHub Actions, but I am familiar with Jenkins, GitLab CI, and CircleCI, and the concepts are similar—checkout → build → test → code quality → artifact."
Code Type	Build Tool	What CI does
Java	Maven / Gradle	mvn package/test, generate JAR/WAR
Python	pip/venv/pytest	install dependencies, test, lint
Node.js	npm/yarn	npm install, build UI, run tests
Go	go build/test	build static binary
.NET	dotnet CLI	restore, build, test